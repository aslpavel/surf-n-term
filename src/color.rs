use crate::common::{clamp, Rnd};
use crate::error::Error;
use std::{
    fmt,
    ops::{Add, Mul},
    str::FromStr,
};

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum Blend {
    Over,
    Out,
    In,
    Atop,
    Xor,
}

pub trait Color: From<ColorLinear> + Into<ColorLinear> + Copy {
    /// Convert color into 32-bit sRGB array with alpha (channels are not pre-multiplied).
    fn rgba_u8(self) -> [u8; 4];

    /// Convert color into 24-bit sRGB array without alpha (channels are not pre-multiplied).
    fn rgb_u8(self) -> [u8; 3] {
        let [r, g, b, a] = self.rgba_u8();
        if a == 255 {
            [r, g, b]
        } else {
            let alpha = a as f64 / 255.0;
            let [r, g, b, _] = ColorLinear([0.0, 0.0, 0.0, 1.0])
                .lerp(self, alpha)
                .rgba_u8();
            [r, g, b]
        }
    }

    /// Blend current color with the other color, with the specified blend method.
    fn blend(self, other: impl Color, method: Blend) -> Self {
        // Reference:
        // https://ciechanow.ski/alpha-compositing/
        // http://ssp.impulsetrain.com/porterduff.html
        let dst = self.into();
        let dst_a = dst.0[3];
        let src = other.into();
        let src_a = src.0[3];
        let color = match method {
            Blend::Over => src + dst * (1.0 - src_a),
            Blend::Out => src * (1.0 - dst_a),
            Blend::In => src * dst_a,
            Blend::Atop => src * dst_a + dst * (1.0 - src_a),
            Blend::Xor => src * (1.0 - dst_a) + dst * (1.0 - src_a),
        };
        color.into()
    }

    /// Linear interpolation between self and other colors.
    fn lerp(self, other: impl Color, t: f64) -> Self {
        let start = self.into();
        let end = other.into();
        let color = start * (1.0 - t) + end * t;
        color.into()
    }

    /// Calculate luma of the color.
    fn luma(self) -> f64 {
        let [r, g, b] = self.rgb_u8();
        0.2126 * (r as f64 / 255.0) + 0.7152 * (g as f64 / 255.0) + 0.0722 * (b as f64 / 255.0)
    }

    /// Pick color that produces the best contrast with self
    fn best_contrast(self, c0: impl Color, c1: impl Color) -> Self {
        let luma = self.luma();
        let c0: ColorLinear = c0.into();
        let c1: ColorLinear = c1.into();
        if (luma - c0.luma()).abs() < (luma - c1.luma()).abs() {
            c1.into()
        } else {
            c0.into()
        }
    }
}

/// Convert Linear RGB color component into a SRGB color component.
///
/// It was hard to optimize this function, even current version
/// is slow because of the conditional jump. Lookup table is not working
/// here as well it should be at least 4K in size an not cache friendly.
#[inline]
pub fn linear_to_srgb(x0: f64) -> f64 {
    if x0 <= 0.0031308 {
        x0 * 12.92
    } else {
        // This function is generated by least square fitting of
        // `f(x) = 1.055 * x.powf(1.0 / 2.4) - 0.055` on value [0.0031308..1.0]
        // see `scripts/srgb.py` for details.
        let x1 = x0.sqrt();
        let x2 = x1.sqrt();
        let x3 = x2.sqrt();
        -0.01848558 * x0 + 0.64455921 * x1 + 0.70994762 * x2 - 0.33605254 * x3
    }
}

/// Color in linear RGB color space with premultiplied alpha
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd)]
pub struct ColorLinear(pub [f64; 4]);

impl Mul<f64> for ColorLinear {
    type Output = Self;

    #[inline]
    fn mul(self, val: f64) -> Self::Output {
        let Self([r, g, b, a]) = self;
        Self([r * val, g * val, b * val, a * val])
    }
}

impl Add<Self> for ColorLinear {
    type Output = Self;

    #[inline]
    fn add(self, other: Self) -> Self::Output {
        let Self([r0, g0, b0, a0]) = self;
        let Self([r1, g1, b1, a1]) = other;
        Self([r0 + r1, g0 + g1, b0 + b1, a0 + a1])
    }
}

impl ColorLinear {
    pub fn new(r: f64, g: f64, b: f64, a: f64) -> Self {
        Self([r, g, b, a])
    }

    pub fn distance(&self, other: &Self) -> f64 {
        let Self([r0, g0, b0, _]) = *self;
        let Self([r1, g1, b1, _]) = *other;
        ((r0 - r1).powi(2) + (g0 - g1).powi(2) + (b0 - b1).powi(2)).sqrt()
    }
}

impl Color for ColorLinear {
    fn rgba_u8(self) -> [u8; 4] {
        RGBA::from(self).rgba_u8()
    }
}

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RGBA(pub [u8; 4]);

impl RGBA {
    /// Generate random opaque colors
    pub fn random() -> impl Iterator<Item = RGBA> {
        let mut rnd = Rnd::new(0);
        std::iter::from_fn(move || {
            let value = rnd.next_u32();
            Some(RGBA::new(
                (value & 0xff) as u8,
                ((value >> 8) & 0xff) as u8,
                ((value >> 16) & 0xff) as u8,
                255,
            ))
        })
    }
}

impl Default for RGBA {
    fn default() -> Self {
        Self([0, 0, 0, 0])
    }
}

impl RGBA {
    pub fn new(r: u8, g: u8, b: u8, a: u8) -> Self {
        RGBA([r, g, b, a])
    }

    pub fn with_alpha(self, alpha: f64) -> Self {
        let Self([r, g, b, _]) = self;
        let a = (clamp(alpha, 0.0, 1.0) * 255.0).round() as u8;
        Self([r, g, b, a])
    }

    pub fn from_str_opt(rgba: &str) -> Option<Self> {
        let rgba = rgba.trim_matches('"');
        if rgba.len() < 7 || !rgba.starts_with('#') || rgba.len() > 9 {
            return None;
        }
        let mut hex = crate::decoder::hex_decode(rgba[1..].as_bytes());
        let red = hex.next()?;
        let green = hex.next()?;
        let blue = hex.next()?;
        let alpha = if rgba.len() == 9 { hex.next()? } else { 255 };
        Some(Self([red, green, blue, alpha]))
    }
}

impl Color for RGBA {
    fn rgba_u8(self) -> [u8; 4] {
        self.0
    }
}

impl From<RGBA> for ColorLinear {
    fn from(color: RGBA) -> Self {
        let [r, g, b, a] = color.rgba_u8();
        let a = (a as f64) / 255.0;
        unsafe {
            let r = SRGB_TO_LIN.get_unchecked(r as usize) * a;
            let g = SRGB_TO_LIN.get_unchecked(g as usize) * a;
            let b = SRGB_TO_LIN.get_unchecked(b as usize) * a;
            ColorLinear([r, g, b, a])
        }
    }
}

impl From<ColorLinear> for RGBA {
    fn from(color: ColorLinear) -> Self {
        let ColorLinear([r, g, b, a]) = color;
        if a < std::f64::EPSILON {
            Self([0, 0, 0, 0])
        } else {
            let a = clamp(a, 0.0, 1.0);
            let r = (linear_to_srgb(r / a) * 255.0).round() as u8;
            let g = (linear_to_srgb(g / a) * 255.0).round() as u8;
            let b = (linear_to_srgb(b / a) * 255.0).round() as u8;
            let a = (a * 255.0) as u8;
            Self([r, g, b, a])
        }
    }
}

impl FromStr for RGBA {
    type Err = Error;

    fn from_str(string: &str) -> Result<Self, Self::Err> {
        Self::from_str_opt(string).ok_or_else(|| Error::ParseError("RGBA", string.to_string()))
    }
}

impl FromStr for ColorLinear {
    type Err = Error;

    fn from_str(string: &str) -> Result<Self, Self::Err> {
        RGBA::from_str(string).map(ColorLinear::from)
    }
}

impl fmt::Display for RGBA {
    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
        let [r, g, b, a] = self.rgba_u8();
        write!(fmt, "#{:02x}{:02x}{:02x}", r, g, b)?;
        if a != 255 {
            write!(fmt, "{:02x}", a)?;
        }
        Ok(())
    }
}

impl fmt::Debug for RGBA {
    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
        let [bg_r, bg_g, bg_b] = self.rgb_u8();
        let [fg_r, fg_g, fg_b] = self
            .best_contrast(RGBA::new(255, 255, 255, 255), RGBA::new(0, 0, 0, 255))
            .rgb_u8();
        write!(
            fmt,
            "\x1b[38;2;{};{};{};48;2;{};{};{}m",
            fg_r, fg_g, fg_b, bg_r, bg_g, bg_b
        )?;
        write!(fmt, "{}", self)?;
        write!(fmt, "\x1b[m")
    }
}

// sRGB to Linear RGB component lookup table
//
// This table is calculating by evaluating `true_s2l` on all u8 values
// fn srgb_to_linear(value: f64) -> f64 {
//     if value <= 0.04045 {
//         value / 12.92
//     } else {
//         ((value + 0.055) / 1.055).powf(2.4)
//     }
// }
// Lookup in this table is fast as it is small enough to fit in the cache
const SRGB_TO_LIN: [f64; 256] = [
    0.0,
    0.0003035269835488375,
    0.000607053967097675,
    0.0009105809506465125,
    0.00121410793419535,
    0.0015176349177441874,
    0.001821161901293025,
    0.0021246888848418626,
    0.0024282158683907,
    0.0027317428519395373,
    0.003035269835488375,
    0.003346535763899161,
    0.003676507324047436,
    0.004024717018496307,
    0.004391442037410293,
    0.004776953480693729,
    0.005181516702338386,
    0.005605391624202723,
    0.006048833022857054,
    0.006512090792594475,
    0.006995410187265387,
    0.007499032043226175,
    0.008023192985384994,
    0.008568125618069307,
    0.009134058702220787,
    0.00972121732023785,
    0.010329823029626936,
    0.010960094006488246,
    0.011612245179743885,
    0.012286488356915872,
    0.012983032342173012,
    0.013702083047289686,
    0.014443843596092545,
    0.01520851442291271,
    0.01599629336550963,
    0.016807375752887384,
    0.017641954488384078,
    0.018500220128379697,
    0.019382360956935723,
    0.0202885630566524,
    0.021219010376003555,
    0.02217388479338738,
    0.02315336617811041,
    0.024157632448504756,
    0.02518685962736163,
    0.026241221894849898,
    0.027320891639074894,
    0.028426039504420793,
    0.0295568344378088,
    0.030713443732993635,
    0.03189603307301153,
    0.033104766570885055,
    0.03433980680868217,
    0.03560131487502034,
    0.03688945040110004,
    0.0382043715953465,
    0.03954623527673284,
    0.04091519690685319,
    0.042311410620809675,
    0.043735029256973465,
    0.04518620438567554,
    0.046665086336880095,
    0.04817182422688942,
    0.04970656598412723,
    0.05126945837404324,
    0.052860647023180246,
    0.05448027644244237,
    0.05612849004960009,
    0.05780543019106723,
    0.0595112381629812,
    0.06124605423161761,
    0.06301001765316767,
    0.06480326669290577,
    0.06662593864377289,
    0.06847816984440017,
    0.07036009569659588,
    0.07227185068231748,
    0.07421356838014963,
    0.07618538148130785,
    0.07818742180518633,
    0.08021982031446832,
    0.0822827071298148,
    0.08437621154414882,
    0.08650046203654976,
    0.08865558628577294,
    0.09084171118340768,
    0.09305896284668745,
    0.0953074666309647,
    0.09758734714186246,
    0.09989872824711389,
    0.10224173308810132,
    0.10461648409110419,
    0.10702310297826761,
    0.10946171077829933,
    0.1119324278369056,
    0.11443537382697373,
    0.11697066775851084,
    0.11953842798834562,
    0.12213877222960187,
    0.12477181756095049,
    0.12743768043564743,
    0.1301364766903643,
    0.13286832155381798,
    0.13563332965520566,
    0.13843161503245183,
    0.14126329114027164,
    0.14412847085805777,
    0.14702726649759498,
    0.14995978981060856,
    0.15292615199615017,
    0.1559264637078274,
    0.1589608350608804,
    0.162029375639111,
    0.1651321945016676,
    0.16826940018969075,
    0.1714411007328226,
    0.17464740365558504,
    0.17788841598362912,
    0.18116424424986022,
    0.184474994500441,
    0.18782077230067787,
    0.19120168274079138,
    0.1946178304415758,
    0.19806931955994886,
    0.20155625379439707,
    0.20507873639031693,
    0.20863687014525575,
    0.21223075741405523,
    0.21586050011389926,
    0.2195261997292692,
    0.2232279573168085,
    0.22696587351009836,
    0.23074004852434915,
    0.23455058216100522,
    0.238397573812271,
    0.24228112246555486,
    0.24620132670783548,
    0.25015828472995344,
    0.25415209433082675,
    0.2581828529215958,
    0.26225065752969623,
    0.26635560480286247,
    0.2704977910130658,
    0.27467731206038465,
    0.2788942634768104,
    0.2831487404299921,
    0.2874408377269175,
    0.29177064981753587,
    0.2961382707983211,
    0.3005437944157765,
    0.3049873140698863,
    0.30946892281750854,
    0.31398871337571754,
    0.31854677812509186,
    0.32314320911295075,
    0.3277780980565422,
    0.33245153634617935,
    0.33716361504833037,
    0.3419144249086609,
    0.3467040563550296,
    0.35153259950043936,
    0.3564001441459435,
    0.3613067797835095,
    0.3662525955988395,
    0.3712376804741491,
    0.3762621229909065,
    0.38132601143253014,
    0.386429433787049,
    0.39157247774972326,
    0.39675523072562685,
    0.4019777798321958,
    0.4072402119017367,
    0.41254261348390375,
    0.4178850708481375,
    0.4232676699860717,
    0.4286904966139066,
    0.43415363617474895,
    0.4396571738409188,
    0.44520119451622786,
    0.45078578283822346,
    0.45641102318040466,
    0.4620769996544071,
    0.467783796112159,
    0.47353149614800955,
    0.4793201831008268,
    0.4851499400560704,
    0.4910208498478356,
    0.4969329950608704,
    0.5028864580325687,
    0.5088813208549338,
    0.5149176653765214,
    0.5209955732043543,
    0.5271151257058131,
    0.5332764040105052,
    0.5394794890121072,
    0.5457244613701866,
    0.5520114015120001,
    0.5583403896342679,
    0.5647115057049292,
    0.5711248294648731,
    0.5775804404296506,
    0.5840784178911641,
    0.5906188409193369,
    0.5972017883637634,
    0.6038273388553378,
    0.6104955708078648,
    0.6172065624196511,
    0.6239603916750761,
    0.6307571363461468,
    0.6375968739940326,
    0.6444796819705821,
    0.6514056374198242,
    0.6583748172794485,
    0.665387298282272,
    0.6724431569576875,
    0.6795424696330938,
    0.6866853124353135,
    0.6938717612919899,
    0.7011018919329731,
    0.7083757798916868,
    0.7156935005064807,
    0.7230551289219693,
    0.7304607400903537,
    0.7379104087727308,
    0.7454042095403874,
    0.7529422167760779,
    0.7605245046752924,
    0.768151147247507,
    0.7758222183174236,
    0.7835377915261935,
    0.7912979403326302,
    0.799102738014409,
    0.8069522576692516,
    0.8148465722161012,
    0.8227857543962835,
    0.8307698767746546,
    0.83879901174074,
    0.846873231509858,
    0.8549926081242338,
    0.8631572134541023,
    0.8713671191987972,
    0.8796223968878317,
    0.8879231178819663,
    0.8962693533742664,
    0.9046611743911496,
    0.9130986517934192,
    0.9215818562772946,
    0.9301108583754237,
    0.938685728457888,
    0.9473065367331999,
    0.9559733532492861,
    0.9646862478944651,
    0.9734452903984125,
    0.9822505503331171,
    0.9911020971138298,
    1.0,
];

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_color() -> Result<(), Error> {
        assert_eq!("#d3869b".parse::<RGBA>()?, RGBA([211, 134, 155, 255]));
        assert_eq!("#b8bb2680".parse::<RGBA>()?, RGBA([184, 187, 38, 128]));
        Ok(())
    }

    #[test]
    fn test_color_linear() -> Result<(), Error> {
        let color = "#fe801970".parse()?;
        assert_eq!(RGBA::from(ColorLinear::from(color)), color);

        for input in 0..256 {
            let output = (linear_to_srgb(SRGB_TO_LIN[input]) * 255.0).round() as u8;
            assert_eq!(input as u8, output);
        }

        Ok(())
    }
}
